package redis

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/dranikpg/gtrs"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/redis/go-redis/v9"
	"go.uber.org/zap"

	"github.com/yanakipre/bot/internal/encodingtooling"
	"github.com/yanakipre/bot/internal/logger"
	"github.com/yanakipre/bot/internal/metrics"
)

type StreamProducerConfig struct {
	// MaxLen specifies the approximate maximum length of the stream.
	// Entries are NOT removed automatically.
	// Entries are removed when new entries are added into the stream.
	// We're using "~" matcher under the hood, so the limit is not strict,
	// it's approximate. Using strict matcher affects performance.
	MaxLen              int64                    `yaml:"max_len"`
	StreamName          string                   `yaml:"stream_name"`
	StreamMonitorTicker encodingtooling.Duration `yaml:"stream_monitor_ticker"`
}

func parseRedisMessageID(s string) int64 {
	part := strings.Split(s, "-")[0] // assume Redis autogenerated ID and take the first part (time)
	res, err := strconv.ParseInt(part, 10, 0)
	if err != nil {
		return 0
	}
	return res
}

func (c *Stream[T]) monitorStream(
	ctx context.Context,
) func() {
	streamName := c.Stream.Key()
	rdb := c.rawClient
	ctx = logger.WithFields(
		ctx,
		zap.String("job_name", "stream_monitor"),
		zap.String("stream", streamName),
	)
	ticker := time.NewTicker(c.monitorTicker)
	return func() {
		for {
			select {
			case <-ctx.Done():
				logger.Info(ctx, "gracefully shutting down stream monitoring")
				return
			case <-ticker.C:
				res, err := rdb.XInfoGroups(ctx, streamName).Result()
				if err != nil {
					logger.Warn(ctx, "XINFO Groups failed", zap.Error(err))
					continue
				}
				for _, rr := range res {
					delivered := parseRedisMessageID(rr.LastDeliveredID)
					c.mDelivered.WithLabelValues(redisName, streamName, rr.Name).
						Set(float64(delivered))
					c.mLag.WithLabelValues(redisName, streamName, rr.Name).Set(float64(rr.Lag))
					c.mPending.WithLabelValues(redisName, streamName, rr.Name).
						Set(float64(rr.Pending))
				}
				res2, err := rdb.XRangeN(ctx, streamName, "-", "+", 1).Result()
				if err != nil {
					logger.Warn(ctx, "XRange N failed", zap.Error(err))
					continue
				}
				if len(res2) == 0 {
					logger.Warn(ctx, "no message returned")
					continue
				}
				c.mFirst.WithLabelValues(redisName, streamName).
					Set(float64(parseRedisMessageID(res2[0].ID)))
				res3, err := rdb.XRevRangeN(ctx, streamName, "+", "-", 1).Result()
				if err != nil {
					logger.Warn(ctx, "XRevRange N failed", zap.Error(err))
					continue
				}
				if len(res3) == 0 {
					logger.Warn(ctx, "no message returned")
					continue
				}
				c.mLast.WithLabelValues(redisName, streamName).
					Set(float64(parseRedisMessageID(res3[0].ID)))
				res4, err := rdb.XLen(ctx, streamName).Result()
				if err != nil {
					logger.Warn(ctx, "XLen failed", zap.Error(err))
					continue
				}
				c.mLen.WithLabelValues(redisName, streamName).
					Set(float64(res4))
			}
		}
	}
}

func DefaultStreamProducerConfig(streamName string) StreamProducerConfig {
	return StreamProducerConfig{
		StreamName:          streamName,
		MaxLen:              10000,
		StreamMonitorTicker: encodingtooling.NewDuration(5 * time.Second),
	}
}

func NewStream[T any](
	client redis.UniversalClient,
	cfg StreamProducerConfig,
) Stream[T] {
	s := Stream[T]{
		Stream: gtrs.NewStream[T](client, cfg.StreamName, &gtrs.Options{
			TTL:    gtrs.NoExpiration,
			MaxLen: cfg.MaxLen,
			Approx: true,
		}),
		mPersist:   metrics.MBusMessagePersistDuration.WithLabelValues(redisName, cfg.StreamName),
		mProdTotal: metrics.MBusMessagesProducedTotal.WithLabelValues(redisName, cfg.StreamName),
		mProdSuccess: metrics.MBusMessagesProducedSuccess.WithLabelValues(
			redisName,
			cfg.StreamName,
		),
		mDelivered:    metrics.MBusMessagesLastDelivered,
		mFirst:        metrics.MBusMessagesFirstStored,
		mLast:         metrics.MBusMessagesLastStored,
		mLen:          metrics.MBusMessagesLen,
		mLag:          metrics.MBusMessagesLag,
		mPending:      metrics.MBusMessagesPending,
		monitorTicker: cfg.StreamMonitorTicker.Duration,
		rawClient:     client,
	}
	return s
}

func (s *Stream[T]) Ready(ctx context.Context) error {
	go s.monitorStream(ctx)()
	return nil
}

// Stream is a producer implementation using Redis-streams.
// https://redis.io/docs/data-types/streams/
type Stream[T any] struct {
	gtrs.Stream[T]
	mPersist      prometheus.Observer
	mProdTotal    prometheus.Counter
	mProdSuccess  prometheus.Counter
	mDelivered    *prometheus.GaugeVec
	mFirst        *prometheus.GaugeVec
	mLast         *prometheus.GaugeVec
	mLen          *prometheus.GaugeVec
	mLag          *prometheus.GaugeVec
	mPending      *prometheus.GaugeVec
	monitorTicker time.Duration
	rawClient     redis.UniversalClient
}

func (s *Stream[T]) Add(ctx context.Context, v T) (string, error) {
	s.mProdTotal.Inc()

	startedAt := time.Now()
	defer func() {
		s.mPersist.Observe(time.Since(startedAt).Seconds())
	}()

	add, err := s.Stream.Add(ctx, v)
	if err != nil {
		return "", fmt.Errorf("could not persist message in redis: %w", err)
	}
	s.mProdSuccess.Inc()
	return add, err
}
